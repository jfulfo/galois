// church nat
fn ctrue(x, y) {
    x
}

fn cfalse(x, y) {
    y
}

fn zero(f, x) {
    x
}

fn is_zero(n) {
    fn always_false(x) {
        cfalse
    }
    n(always_false, ctrue)
}

fn succ(n) {
    fn succ_inner(f, x) {
        f(n(f, x))
    }
    succ_inner
}

fn add(m, n) {
    n(succ, m)
}


fn mult(m, n) {
    n(add(m, zero), zero)
}


fn one() {
    return succ(zero)
}

fn two() {
    return succ(one())
}

fn three() {
    return succ(two())
}

fn id(x) {
    x
}

fn pair(a, b) {
    fn pair_inner(f) {
        f(a, b)
    }
    pair_inner
}

fn first(p) {
    p(ctrue)
}

fn second(p) {
    p(cfalse)
}

fn pred(n) {
    fn pred_inner(f, x) {
        fn g(p) {
            pair(f(first(p)), first(p))
        }
        second(n(g, pair(x, x)))
    }
    pred_inner
}

fn minus(m, n) { // m - n
    return n(pred, m)
}

notation "$x + $y" with x, y precedence 10 associativity left := add(x, y)
notation "$x * $y" with x, y precedence 20 associativity left := mult(x, y)
notation "$x - $y" with x, y precedence 10 associativity left := minus(x, y)

z = one() + two()
is_zero(z - three())
